// Generated by CoffeeScript 2.3.1
var EventEmitter, Kafka, Promise, Samsa, addPromiseMethods, exit, exitWrapped, exiters, uuid,
  indexOf = [].indexOf;

Kafka = require('kafka-node');

Promise = require('bluebird');

uuid = require('uuid');

({EventEmitter} = require('events'));

exit = new EventEmitter;

exiters = [];

exitWrapped = async function() {
  await Promise.all(exiters.map(function(e) {
    return e();
  }));
  return process.exit();
};

exit.on('exit', exitWrapped);

// process.on 'exit', -> exit.emit 'exit'
process.on('SIGINT', function() {
  return exit.emit('exit');
});

process.on('SIGTERM', function() {
  return exit.emit('exit');
});

addPromiseMethods = function(obj) {
  return Promise.promisifyAll(obj, {
    suffix: 'Promise'
  });
};

module.exports = Samsa = class Samsa {
  constructor(name, methods = {}, config = {}) {
    this.name = name;
    this.methods = methods;
    this.config = config;
    this.host = this.config.host || '127.0.0.1:9092';
    this.kafka = addPromiseMethods(new Kafka.KafkaClient({
      kafkaHost: this.host
    }));
    this.createProducer();
    if (this.name != null) {
      this.createConsumerGroup();
    } else {
      this.createConsumer();
    }
    this.consuming_topics = [];
    this.hooks = {};
    this.subscriptions = {};
    this.exitOnClose();
  }

  exitOnClose() {
    return exiters.push(() => {
      return new Promise((resolve, reject) => {
        return this.consumer.close(function() {
          return resolve();
        });
      });
    });
  }

  close() {
    return this.consumer.closePromise();
  }

  createProducer() {
    var producer_options;
    producer_options = {
      partitionerType: 1
    };
    return this.producer = addPromiseMethods(new Kafka.Producer(this.kafka, producer_options));
  }

  createConsumerGroup() {
    var consumer_group_options;
    consumer_group_options = {
      host: this.host,
      groupId: this.name
    };
    this.consumer = addPromiseMethods(new Kafka.ConsumerGroup(consumer_group_options, [this.name]));
    return this.consumer.on('message', this.handleMessage.bind(this));
  }

  createConsumer() {
    var consumer_options, consumer_payloads;
    if (this.name != null) {
      consumer_payloads = [
        {
          topic: this.name
        }
      ];
      consumer_options = {
        groupId: this.name
      };
    } else {
      consumer_payloads = [];
    }
    this.consumer = addPromiseMethods(new Kafka.Consumer(this.kafka, consumer_payloads, consumer_options));
    return this.consumer.on('message', this.handleMessage.bind(this));
  }

  createTopic(topic) {
    return this.kafka.createTopicsPromise([topic]);
  }

  async consumeTopic(topic) {
    var added;
    this.consuming_topics.push(topic);
    await this.createTopic(topic);
    return added = (await this.consumer.addTopicsPromise([topic]));
  }

  async handleMessage(full_message) {
    var err, error, hook, id, message, method, ref, ref1, response, sent, subscription;
    message = JSON.parse(full_message.value);
    if (hook = this.hooks[message.id]) {
      delete this.hooks[message.id];
      return hook(message);
    } else if (method = (ref = this.methods) != null ? ref[message.method] : void 0) {
      try {
        response = (await method(...message.args));
      } catch (error1) {
        err = error1;
        error = err;
      }
      id = message.id + '-response';
      return sent = (await this.send(message.service + '-response', {id, response, error}));
    } else if (subscription = (ref1 = this.subscriptions) != null ? ref1[message.service] : void 0) {
      return subscription(message);
    }
  }

  async send(topic, message) {
    var sent;
    return sent = (await this.producer.sendPromise([
      {
        topic: topic,
        messages: [JSON.stringify(message)]
      }
    ]));
  }

  async request(service, method, ...args) {
    var hook, id, sent;
    if (indexOf.call(this.consuming_topics, service) < 0) {
      await this.consumeTopic(service + '-response');
    }
    id = uuid();
    hook = new Promise((resolve, reject) => {
      return this.hooks[id + '-response'] = function(message) {
        if (message.error) {
          return reject(message.error);
        } else {
          return resolve(message.response);
        }
      };
    });
    sent = (await this.send(service, {id, service, method, args}));
    return hook;
  }

  async subscribe(service, subscription) {
    if (indexOf.call(this.consuming_topics, service) < 0) {
      await this.consumeTopic(service);
    }
    return this.subscriptions[service] = subscription;
  }

};
